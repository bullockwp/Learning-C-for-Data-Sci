#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"
#include <map>

template<class T>
class SparseVector
{
private:
    unsigned int mDim; // Dimensionality of SV
    std::vector<T> mValues; // non-0 values in sparsevector
    std::vector<unsigned int> mIndex; // positions in sparsevector
public:
	//creates an empty vector of dimensionality 0.
	SparseVector();
	// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
	// which need to be set using setValue
	SparseVector(unsigned int dim);

	// assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	//sets the value v_i of the vector. if it does not exist it is added 
	void setValue(unsigned int index, T value);
	
	//returns the value v_i of the vector. Returns 0 if the value is not stored
	T getValue(unsigned int index)const;
	
	//returns the dimensionality of the vector
	unsigned int size()const;
	
	// returns the number stored elements
	unsigned int nonZeroes()const;

    //returns the index of the ith stored nonzero entry (in increasing order) // give Fun mIndices[#] get corresponding mContent[#]
	unsigned int indexNonZero(unsigned int i)const;

    //returns the value of the ith stored nonzero entry (in increasing order) // give Fun mContent[#] get  corresponding mIndices[#]
	T valueNonZero(unsigned int i)const;
	
	//adds x to the current vector
	SparseVector<T>& operator+= (SparseVector<T> const& x);
	//subtracts x from the current vector
	SparseVector<T>& operator-= (SparseVector<T> const& x);
};


// Constructor for vector of a 0 dim
template <class T> SparseVector<T>::SparseVector()
{
    mDim = 0;
}

// Constructor for vector of a given size
// Allocates memory, and initialises entries
// to zero
template <class T> SparseVector<T>::SparseVector(unsigned int dim)
{
    assert(dim > 0);
    mDim = dim;
}

//sets the value v_i of the vector. if it does not exist it is added
template <class T> void SparseVector<T>::setValue(unsigned int index, T value) {
    // search to see if value already present
    std::vector<unsigned int>::const_iterator lower;
    lower = std::lower_bound(mIndex.begin(), mIndex.end(), index);
    //if not found, append.
    if (lower == mIndex.end()) {
        mValues.push_back(value);
        mIndex.push_back(index);
        //if true; overwrite.
    } else if (index == *lower) {
        mValues[lower - mIndex.begin()] = value;
        //otherwise insert.
    } else {
        mValues.insert(mValues.begin() + (lower - mIndex.begin()), value);
        mIndex.insert(mIndex.begin() + (lower - mIndex.begin()), index);
    }

    }

//returns the value v_i of the vector. Returns 0 if the value is not stored
template <class T> T SparseVector<T>::getValue(unsigned int index)const
{
    T content;
    // search for value for index
    std::vector<unsigned int>::const_iterator it;

    it = std::lower_bound(mIndex.begin(), mIndex.end(), index);
    if (index == *it) {
        content = mValues[it - mIndex.begin()];
    }else{
        content = 0;
    }

    return content;
}

template <class T> unsigned int SparseVector<T>::size()const
{
    return mDim;
}

// returns the number stored elements
template <class T> unsigned int SparseVector<T>::nonZeroes()const
{
    return mIndex.size();
}

//returns the index of the ith stored nonzero entry (in increasing order)
template <class T> unsigned int SparseVector<T>::indexNonZero(unsigned int i)const
{
    return mIndex[i];
}

//returns the value of the ith stored nonzero entry (in increasing order)
template <class T> T SparseVector<T>::valueNonZero(unsigned int i)const
{
    return mValues[i];
}


template <class T> SparseVector<T>& SparseVector<T>::operator+= (SparseVector<T> const& x)
{
    for (unsigned int i=0; i < x.nonZeroes(); i++){

        setValue(x.indexNonZero(i), getValue(x.indexNonZero(i)) + x.valueNonZero(i));
    }
}

template <class T> SparseVector<T>& SparseVector<T>::operator-= (SparseVector<T> const& x)
{
    for (unsigned int i=0; i < x.nonZeroes(); i++){

        setValue(x.indexNonZero(i), getValue(x.indexNonZero(i)) - x.valueNonZero(i));
    }
}

//MATHEMATICS
// computes z= x+y, equivalent to z=x, z+=y
template<class T> SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y)
{
    SparseVector<T> z;
    z = x;
    z += y;
    return z;
}

// computes z= x-y, equivalent to z=x, z-=y
template<class T> SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y)
{
    SparseVector<T> z;
    z = x;
    z -= y;
    return z;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T> Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x){

    int original_vector_size = x.nonZeroes();
    assert(A.GetNumberOfColumns() == original_vector_size);
    int new_vector_length = A.GetNumberOfRows();
    Vector<T> new_vector(new_vector_length);

    for (int i=0; i<new_vector_length; i++)
    {
        for (unsigned int j=0; j<original_vector_size; j++)
        {
            new_vector[i] += A(i,j)*x.valueNonZero(j);
        }
    }
    return new_vector;

}

// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T> Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A)
{
    int original_vector_size = x.nonZeroes();
    assert(A.GetNumberOfColumns() == original_vector_size);
    int new_vector_length = A.GetNumberOfRows();
    Vector<T> new_vector(new_vector_length);

    for (int i=0; i<new_vector_length; i++)
    {
        for (int j=0; j<original_vector_size; j++)
        {
            new_vector[i] += x.valueNonZero(j)*A(j,i);
        }
    }

    return new_vector;
}



#endif